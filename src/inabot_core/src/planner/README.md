# Planner 구조 및 역할 정리


[FMS] 
   │
   ▼
/goal_pose (목표 좌표 발행)
   │
   ▼
[글로벌 플래너]  (goal_pose 구독) - A*
   │
   ▼
/global_plan (경로 생성 및 발행)
   │
   ▼
[로컬 플래너] (global_plan 구독)
   │
   ▼
/cmd_vel (제어 명령 발행)
   │
   ▼
[로봇 제어 노드] (cmd_vel 구독)
   │
   ▼
모터 제어 (로봇 움직임)



+---------+          +-------------+          +-----------+          +------------+          +-------------+
|   FMS   |  ---->   | 글로벌 플래너 |  ---->   | 로컬 플래너 |  ---->   | 로봇 제어 노드 |  ---->   | 모터 제어  |
| (goal_pose)        | (goal_pose)  |          | (global_plan) |        | (cmd_vel)      |          | (로봇 움직임)|
+---------+          +-------------+          +-----------+          +------------+          +-------------+
         publish              subscribe                subscribe              subscribe
         /goal_pose            /goal_pose              /global_plan            /cmd_vel
                             publish /global_plan      publish /cmd_vel


# Overview

planner 폴더는 로봇 경로 계획과 제어 관련 코드를 포함합니다. 크게 Global Planner(전역 계획기) 와 Local Planner(지역 계획기)

# Global Planner (전역 계획기)

    로봇이 목표 지점까지 도달하기 위한 전체 경로(waypoints)를 생성

    주로 맵 기반이며, 출발지부터 목표지까지 최적 경로나 경로 후보를 계산

    대표 알고리즘 예:

        A*

        Dijkstra

        RRT (Rapidly-exploring Random Tree)

# Local Planner (지역 계획기)

    글로벌 플래너가 제공한 경로를 따라갈 수 있도록 실제 로봇 제어 명령(cmd_vel) 을 생성

    현재 위치(odom)와 센서 데이터를 바탕으로 장애물 회피 및 세부 경로 수정도 담당

    대표 알고리즘 예:

        Pure Pursuit (경로 추종 제어)

        MPC (Model Predictive Control, 모델 예측 제어)

        Dynamic Window Approach (DWA)
## 요약

 
| 구분          | 역할                                    | 예시 알고리즘                                          |
| -----------    | ------------------------------------- | ------------------------------------------------ |
| **글로벌 플래너** | 맵 기반, 출발지 → 목표지 경로 생성                 | A\*, Dijkstra, RRT
| **로컬 플래너**   | 현재 위치와 목표 경로를 이용해 로봇이 실제 움직일 속도 명령 생성 | Pure Pursuit, MPC, Dynamic Window Approach (DWA) |


장애물 인지(Obstacle Detection) 위치 관련

    글로벌 플래너:

        주로 큰 환경(맵) 단위에서 경로를 계획합니다.

        장애물을 인지해서 전역 경로 생성 시 장애물 회피를 반영해야 합니다.

        즉, 큰 범위, 고정 장애물이나 최근 알려진 장애물 정보를 반영하는 것이 맞습니다.

    로컬 플래너:

        글로벌 경로를 따라 움직이면서

        실제 센서(예: LiDAR, 카메라)로 감지하는

        실시간 동적 장애물(사람, 움직이는 물체 등)을 감지하고 회피합니다.

        좁은 범위, 빠른 반응 필요 시 처리합니다.

따라서,

    정적 장애물이나 맵에 이미 포함된 장애물은 글로벌 플래너에서 인지 및 반영

    동적 장애물이나 센서 기반 실시간 장애물은 로컬 플래너에서 처리하는 구조가 일반적입니다.

요약
장애물 인지 위치	역할	처리 대상
글로벌 플래너	경로 계획 시 장애물 반영	맵 기반, 정적 장애물
로컬 플래너	실시간 회피 및 제어	센서 감지 동적 장애물


# 플로우 다이어그램 구조

[목표 위치]
      │
      ▼
[글로벌 플래너]
   입력: 지도, 시작 위치, 목표 위치
   출력: 전체 경로 (waypoints)
      │
      ▼
[로컬 플래너]
   입력: 현재 위치(odom), 센서 데이터, 글로벌 경로
   출력: 제어 명령 (cmd_vel)
      │
      ▼
[로봇 모터 제어]


+------------+       +----------------+       +----------------+       +-----------------+
|  목표 위치  | ----> |  글로벌 플래너  | ----> |   로컬 플래너   | ----> |  제어 명령(cmd_vel) |
+------------+       +----------------+       +----------------+       +-----------------+
                         ▲                         ▲
                         |                         |
                   지도 및 환경 정보         현재 위치, 센서 데이터


📌 Pure Pursuit Path Following with Dummy Odom and Path Generator (ROS 2)
🔧 시스템 구성 요약

본 패키지는 다음과 같은 구조로 구성되어 있습니다:
1. DummyOdomAndPathNode (Python 노드)

    /cmd_vel 구독 → 로봇의 이동 명령 수신

    /odom 발행 → 내부 상태 기반 더미 오돔 위치 발행

    /goal_reached 수신 → 도착 시 다음 목표점 생성

    /plan 발행 → 목표점 1개를 포함한 경로(Path) 발행

2. PurePursuitNode (C++ 노드)

    /plan 구독 → 목표 경로 수신 (1개 Pose 포함)

    /odom 구독 → 현재 로봇 위치 수신

    /cmd_vel 발행 → 선속도 및 각속도 명령 발행

    /goal_reached 발행 → 목표 도달 시 True 발행

    ✅ Pure Pursuit 알고리즘 수행:

        lookahead 거리 동적 조정

        목표점 곡률 계산

        속도 기반 steering 명령 산출

🧠 함수 동작 원리
quaternion_from_euler(roll, pitch, yaw)

3D 공간 회전을 표현하기 위해 Euler 각도(roll, pitch, yaw)를 쿼터니언으로 변환하는 함수입니다.

def quaternion_from_euler(roll, pitch, yaw):
    ...
    return [qx, qy, qz, qw]

매개변수

    roll, pitch, yaw는 각각 X, Y, Z축 기준 회전 (라디안)

리턴값

    [qx, qy, qz, qw]: 쿼터니언 (3D 회전 표현)

🗺️ 노드 구조도

+----------------------------------------------------------------------------------------+
|   PurePursuitNode (C++)                                                               |
|                                                                                       |
|   1. /cmd_vel  발행 → 선속도/각속도 명령                                              |
|   2. /odom 수신 (Dummy 노드로부터)                                                     |
|   3. /plan 수신 (Path 포인트 1개씩)                                                    |
|   4. 목표점 도달 시 /goal_reached 발행                                                |
|   5. Pure Pursuit 알고리즘 실행                                                       |
+----------------------------------------------------------------------------------------+
            ▲                                                    |
            |                                                    | /goal_reached
            |                                                    v
+---------------------------+      /plan (목표 경로)         +---------------------------+
| DummyOdomAndPathNode      | ------------------------------> | PurePursuitNode           |
|                           |                                 |                           |
| 1. /cmd_vel 구독          |                                 |                           |
| 2. /odom 발행 (더미 오돔) | <------------------------------ | /odom 구독                |
| 3. 목표 도달 시 /plan 발행|                                 |                           |
+---------------------------+                                 +---------------------------+

🚀 실행 방법 (Simulation)
1. Dummy 경로 및 오돔 노드 실행
 
python3 dummy_path_test_node.py

2. Pure Pursuit 노드 실행

ros2 launch pure_pursuit_planner path_planner.launch.py

🔁 동작 흐름 요약

    Dummy 노드가 초기 목표 생성 후 /plan에 1개 포인트 발행

    PurePursuitNode가 /plan, /odom을 바탕으로 /cmd_vel 계산

    목표 도달 시 /goal_reached 발행

    Dummy 노드가 다음 경로 포인트 추가 후 /plan 재발행

    반복...

💡 참고 사항

    frame_id: 'odom'으로 고정

    시간 스탬프: self.get_clock().now().to_msg() 사용

    쿼터니언 변환 필수 (Y축 회전 시 yaw만 사용해도 무방)

필요시 추가할 수 있는 항목:

RViz에서 경로 시각화 방법

lookahead 거리 튜닝 방법

목표 도달 판단 기준 설정


| 구분      | Pure Pursuit                 | MPC               |
| ------- | ---------------------------- | ----------------- |
| 목표 점 개수 | 단일 목표점 (lookahead 기준 한 점 추적) | 여러 점(예측 구간 다수) 활용 |
| 입력 경로   | 여러 점 리스트, 추적할 단일 점만 선택       | 여러 점 시퀀스 입력       |
| 제어 출력   | 단일 속도 명령 (cmd\_vel)          | 최적화된 여러 제어 입력 시퀀스 |
| 복잡도     | 비교적 단순                       | 상대적으로 복잡, 계산량 많음  |


==
알고리즘 테스트 방법
cd /home/ysh/inabot_ws/python/
python3 dummy_path_test_node.py

2. Pure Pursuit 노드 or MPC 실행

ros2 launch inabot_core inabot_core.launch.py







글로벌 플래너에 장애물 인지 + 멈춤 처리 하는 장점

    중앙 집중적 관리
    글로벌 플래너가 전체 경로와 장애물을 관리하니, 장애물 감지 후 전체 경로 재계산하거나 정지 명령 내리기 쉽습니다.

    복잡성 감소
    로컬 플래너나 MPC 모션 컨트롤러는 경로 추종과 제어에 집중해서 코드가 간단해짐.

    센서 융합 편리
    여러 센서 데이터를 글로벌 플래너에서 합쳐서 처리 가능.

    안정성
    글로벌 차원에서 판단해서 장애물에 따른 멈춤이 더 일관되게 관리될 수 있음.

단점 및 고려사항

    응답성
    글로벌 플래너가 주로 느리게 동작한다면, 장애물 대응이 늦을 수 있음. (하지만 물류 로봇 속도가 느리면 큰 문제 없을 가능성 높음)

    동적 장애물 처리
    너무 동적인 장애물은 로컬에서 바로 멈추는 게 더 빠르지만, 물류 로봇 환경 특성상 그렇게 빠르게 움직이지 않는다면 글로벌에서 충분히 커버 가능.

구조 예시

[FMS] 
   │
   ▼
/goal_pose (목표 좌표 발행)
   │
   ▼
[글로벌 플래너]  (goal_pose + 장애물 센서 데이터 구독) - A*
   │
   ├── 장애물 감지 -> 멈춤 플래그 발행 (예: /stop_cmd or /motion_enable)
   │
   ▼
/global_plan (경로 생성 및 발행)
   │
   ▼
[로컬 플래너] (global_plan + 멈춤 플래그 구독)
   │
   ├── 멈춤 플래그 받으면 /cmd_vel 제로 발행
   │
   ▼
/cmd_vel (제어 명령 발행)
   │
   ▼
[로봇 제어 노드] (cmd_vel 구독)
   │
   ▼
모터 제어 (로봇 움직임)  

결론

    물류로봇 특성 상 복잡한 로컬 장애물 회피보다 글로벌 플래너에 장애물 감지 및 멈춤 로직 두는 것이 더 깔끔하고 유지보수에 유리함.

    장애물 정보는 글로벌 플래너에서 받고, 멈춤 신호를 별도로 발행하면 로컬 플래너는 그냥 정지 여부만 판단해서 간단히 처리 가능.