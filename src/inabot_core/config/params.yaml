motor_driver:
  ros__parameters:
    interface_name: "can0"
    can_type: "dummy"  # dummy or socket
    controller_type: "dummy"  # "dummy" or "roboteq"
    drive_type: "traction_steering"  # "traction_steering" or "differential"
 
    # Kinematics parameters
    wheel_radius: 0.05              # [m] radius of each wheel
    wheel_base: 0.3                 # [m] distance between front and rear wheel centers
    wheel_separation: 0.3           # [m] distance between left and right wheels

    # Motor kinematics parameters
    pulse_per_revolution: 10000     # encoder pulses per full wheel revolution
    gear_ratio: 30.0                # gear ratio: motor turns per wheel turn

    use_motor_load_monitor: true        # whether to enable load estimation functionality

    # Velocity profile parameters
    use_velocity_profile: true
    acc:
      linear:
        x: 0.2    # linear acceleration in x [m/s²]
        y: 0.02   # linear acceleration in y [m/s²]
      angular:
        z: 0.1    # angular acceleration in z [rad/s²]
    
    control_hz: 100.0  # control frequency in Hz (e.g., 50.0 = 20ms, 100 = 10ms)

    # PID parameters
    motion_type : "pid"
    traction_pid:
      p: 0.9       # strong response to target linear velocity (fast tracking)
      i: 0.01      # small integral term to avoid long-term drift
      d: 0.05      # helps suppress vibration (low P minimizes oscillations)
      i_clamp: 1.0 # clamp for integral windup (also max linear velocity)
      max_linear: 1.0  # maximum linear speed [m/s]

    steering_pid:
      p: 0.9         # fast response to target angular velocity
      i: 0.02        # minor correction for angular drift
      d: 0.1         # suppresses oscillations and overshoot
      i_clamp: 1.0   # clamp for integral windup
      max_angular: 1.0  # maximum angular speed [rad/s]

odometry_node:
  ros__parameters:
    drive_type: "traction_steering"  # "traction_steering" or "differential"
    wheel_radius: 0.05
    wheel_base: 0.3
    wheel_separation: 0.3
    pulse_per_revolution: 10000       # encoder pulses per full wheel revolution
    use_combine_imu: false            # if true, combines encoder + IMU yaw for odometry

monitor_node:
  ros__parameters:
    bridge_router_ip: "211.195.215.1"
    factory_router_ip: "8.8.8.8"
    disk_device: "nvme0n1"
    use_network_monitor: false
    use_system_monitor: true

imu_node:
  ros__parameters:
    port: '/dev/ttyIMU'       # device name, e.g., ttyACM0 or ttyIMU
    baudrate: 115200
    timeout: 3000             # timeout in milliseconds
    mode: 'relative'          # either 'relative' or 'absolute'
    frame: 'imu_link'         # frame ID for IMU data

# global_planner
global_planner_node:
  ros__parameters:
    obstacle_stop_threshold: 1.0
    obstacle_resume_threshold: 1.3
    enable_a_start: false
    min_safe_distance: 0.5 # 예: 50cm 안전거리
    allow_unknown_area: False # 미지정 영역 허용 안함
    path_point_sampling_interval: 5 # 5점마다 검사

# local planner_1
pure_pursuit:
  ros__parameters:
    lookahead_distance: 1.0
    max_linear_velocity: 0.5
    max_angular_velocity: 1.0
    control_rate: 50.0
    min_lookahead_distance: 0.3
    max_lookahead_distance: 2.0
    goal_threshold: 0.1
    obstacle_stop_threshold: 0.6
    # obstacle
    max_stop_distance: 1.0        # 장애물 감지 최대 거리(m) : 	감속 시작
    min_safe_distance: 0.4        # 최소 안전 거리(m) : 완전 정지

# local planner_2
mpc_motion_controller:
  ros__parameters:
    mpc_steps: 10.0                   # 예측 단계 수
    mpc_dt: 0.02                     # 제어 주기(20ms)
    mpc_ref_cte: 0.0                 # 목표 횡방향 오차
    mpc_ref_etheta: 0.0              # 목표 자세 오차
    mpc_ref_velocity: 0.5            # 목표 속도 (0.5 m/s)
    mpc_weight_cte: 5000.0           # 횡방향 오차 페널티 가중치
    mpc_weight_etheta: 5000.0        # 자세 오차 페널티 가중치
    mpc_weight_velocity: 1.0         # 속도 유지 페널티 가중치
    mpc_weight_angvel: 100.0         # 각속도 크기 페널티
    mpc_weight_accel: 50.0           # 가속도 크기 페널티
    mpc_weight_dangvel: 10.0         # 각속도 변화량 페널티
    mpc_weight_daccel: 10.0          # 가속도 변화량 페널티
    mpc_max_angular_velocity: 1.5    # 최대 각속도 제한(rad/s)
    mpc_max_throttle: 1.0            # 최대 가속도 제한(m/s²)
    mpc_bound_value: 1000.0          # 최적화 변수 제한 값
    goal_threshold: 0.1              # 목표 도달 임계값(m)
    max_speed: 0.5                   # 최대 속도 제한(m/s)
    delay_mode: false
    interp_spacing: 0.4
    min_points: 4
    # obstacle
    max_stop_distance: 1.0        # 장애물 감지 최대 거리(m) : 	감속 시작
    min_safe_distance: 0.4        # 최소 안전 거리(m) : 완전 정지

lidar_obstacle_detector:
  ros__parameters:
    avoid_back_speed: -0.2        # 장애물 회피 시 후진 속도 (m/s, 음수)
    use_visual: true             # 시각화 사용 여부 (true/false)
    
    # ROI: 전방 장애물 감지 영역 (로봇 앞부터 1m, 좌우 ±0.6m)
    #min_x: 0.2   # 로봇 앞 20cm부터 감지
    #max_x: 0.8   # 최대 감지 거리 80cm
    #min_y: -0.4  # 좌측 40cm
    #max_y: 0.4   # 우측 40cm
    min_x: 0.0
    max_x: 1.6 #
    min_y: -0.6
    max_y: 0.6
    # polygon: List of robot outline vertices as (x, y) pairs in a flat array.
    # Each pair represents a point in the base_link coordinate frame.
    # Update the values below to match your robot's actual shape and size.
    # Example: front-right (x=0.401m, y=0.27346m), front-left, rear-left, rear-right.
    polygon: [0.401, 0.27346, 0.401, -0.27346, -0.401, -0.27346, -0.401, 0.27346]


###
laser_scan_merger:
  ros__parameters:
    # General parameter for the integrated laserscan
    integrated_topic: "scan_merged"        # scan_merge, scan
    integrated_frame_id: "base_scan"

    # First laserscan
    scan_topic_1: "scan_front"
    laser_1_x_off: 0.0
    laser_1_y_off: 0.0
    laser_1_yaw: 0.0
    show_1: true

    # Second laserscan
    scan_topic_2: "scan_rear"
    laser_2_x_off: 0.0
    laser_2_y_off: 0.0
    laser_2_yaw: 0.0
    show_2: true

    # Robot dimensions (for obstacle ROI / clipping)
    robot_front_end: 0.1   # [m]
    robot_rear_end: 0.1
    robot_right_end: 0.1
    robot_left_end: 0.1

    # Remove points within this radius (optional)
    remove_radius: 0.2     # [m]
    use_time_synchronizer: true  # true: enable message_filters TimeSynchronizer
    publish_occupancy_grid: false  # true: enable publish_occupancy_grid
